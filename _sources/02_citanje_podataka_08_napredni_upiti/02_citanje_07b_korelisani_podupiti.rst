.. -*- mode: rst -*-

Корелисани подупити
-------------------

Сви приказани угнежђени подупити до сада су били такви да се унутрашњи
упит (тзв. подупит) може извршити независно од спољашњег. Међутим, SQL
допушта и да се у унутрашњем упиту врши филтрирање на основу вредности
наведене у спољашњем подупиту. У том случају кажемо да су упити
**корелисани**.

Корелисани подупити превазилазе домет овог курса. За оне који желе да знају више, 
приказаћемо неколико примера. 

.. questionnote::
           
   Приказати податке о изостанцима ученика који се зову Петар.

Овај упит се природно може написати коришћењем спајања табела ученика
и изостанака. Ипак, приказаћемо решење које користи корелисани
подупит. У спољашњем упиту читамо податке из табеле изостанака, а у
подупиту читамо име ученика чији идентификатор одговара идентификатору
у текућој врсти прочитаној из табеле изостанака и онда изостанке
филтрирамо на основу тога да ли је тако добијено име једнако
``Петар``.
   
.. code-block:: sql

   SELECT *
   FROM izostanak i
   WHERE 'Петар' = (SELECT ime
                    FROM ucenik u
                    WHERE u.id = i.id_ucenik);

Извршавањем упита добија се следећи резултат:

.. csv-table::
   :header:  "id", "id_ucenik", "datum", "cas", "status"
   :align: left

   "1", "1", "2021-05-14", "1", "оправдан"
   "2", "1", "2021-05-14", "2", "неоправдан"
   "3", "4", "2021-05-14", "1", "нерегулисан"
   "4", "4", "2021-05-14", "2", "нерегулисан"
   "6", "1", "2021-05-14", "3", "оправдан"
   ..., ..., ..., ..., ...

Корелисани подупити не морају да се јаве само у клаузули WHERE.

.. questionnote::

   За сваког ученика приказати име, презиме, просек свих добијених
   оцена и просек свих добијених оцена ученика његовог одељења.

Задатак можемо решити корелисаним упитом тако што се на месту четврте
колоне напише упит који филтрира табелу оцена тако што узме само
ученике одељења у ком се налази тренутни ученик и за њих израчуна
просечну оцену. У главном упиту вршимо груписање свих оцена на основу
идентификатора ученика и за сваку групу рачунамо просек (то ће бити
просечне оцене свих ученика).
   
.. code-block:: sql

   SELECT ime, prezime, ROUND(AVG(ocena), 2) AS prosek_ucenika,
           (SELECT ROUND(AVG(ocena), 2)
            FROM ucenik u1 JOIN 
                 ocena o1 ON u1.id = o1.id_ucenik
            WHERE u.razred = u1.razred AND u.odeljenje = u1.odeljenje) AS prosek_odeljenja
   FROM ucenik u JOIN
        ocena o ON u.id = o.id_ucenik
   GROUP BY u.id                

Извршавањем упита добија се следећи резултат:

.. csv-table::
   :header:  "ime", "prezime", "prosek_ucenika", "prosek_odeljenja"
   :align: left

   "Петар", "Петровић", "4.12", "3.64"
   "Милица", "Јовановић", "3.71", "3.64"
   "Лидија", "Петровић", "3.74", "3.64"
   "Петар", "Миловановић", "2.97", "3.73"
   "Ана", "Пекић", "3.12", "3.73"
   ..., ..., ..., ...

Мана оваквог решења је то што се просек оцена одељења рачуна више пута
(за сваког ученика одељења по једном).

Боље решење можемо добити ако у засебном подупиту израчунамо просечне
оцене свих одељења и онда извршимо спајање тако добијене табеле са
табелом која садржи просечне оцене свих ученика (ту користимо
угнежђене, али не и корелисане подупите).

.. code-block:: sql

   SELECT ime, prezime, prosek_ucenika, t1.razred, t1.odeljenje, prosek_odeljenja
   FROM (SELECT ime, prezime, id_ucenik, razred, odeljenje, ROUND(AVG(ocena), 2) AS prosek_ucenika 
         FROM ucenik u JOIN
              ocena o ON u.id = o.id_ucenik
         GROUP BY u.id) t1 JOIN
        (SELECT razred, odeljenje, ROUND(AVG(ocena), 2) AS prosek_odeljenja
         FROM ucenik u JOIN
              ocena o ON u.id = o.id_ucenik
         GROUP BY razred, odeljenje) t2 ON t1.razred = t2.razred AND t1.odeljenje = t2.odeljenje;

Извршавањем упита добија се следећи резултат:

.. csv-table::
   :header:  "ime", "prezime", "prosek_ucenika", "razred", "odeljenje", "prosek_odeljenja"
   :align: left

   "Петар", "Петровић", "4.12", "1", "1", "3.64"
   "Милица", "Јовановић", "3.71", "1", "1", "3.64"
   "Лидија", "Петровић", "3.74", "1", "1", "3.64"
   "Петар", "Миловановић", "2.97", "2", "1", "3.73"
   "Ана", "Пекић", "3.12", "2", "1", "3.73"
   ..., ..., ..., ..., ..., ...

